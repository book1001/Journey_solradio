// ==================================================================
// Ï∫êÏãú
// ==================================================================
const CACHE_NAME = "music-player-cache-v1";
const urlsToCache = [
  "/",
  "/index.html",
  "/manifest.json",
  "/index.css",
  "/index.js",
  // ÌïÑÏöîÌïú Í∏∞ÌÉÄ Ï†ïÏ†Å ÏûêÏõêÎì§
];

// ÏÑ§Ïπò Ïãú Ï∫êÏãú Ï†ÄÏû•
self.addEventListener("install", event => {
  event.waitUntil(
    caches.open(CACHE_NAME).then(cache => cache.addAll(urlsToCache))
  );
});

// ÌôúÏÑ±Ìôî Ïãú Ïù¥Ï†Ñ Ï∫êÏãú Ï†úÍ±∞
self.addEventListener("activate", event => {
  event.waitUntil(
    caches.keys().then(keys =>
      Promise.all(keys.filter(key => key !== CACHE_NAME)
      .map(key => caches.delete(key)))
    )
  );
});

// ÎÑ§Ìä∏ÏõåÌÅ¨ ÏöîÏ≤≠ Í∞ÄÎ°úÏ±ÑÍ∏∞ (Ï∫êÏãú Ïö∞ÏÑ† Ï†ÑÎûµ)
self.addEventListener("fetch", event => {
  event.respondWith(
    caches.match(event.request).then(response => {
      return response || fetch(event.request);
    })
  );
});


// ==================================================================
// Playlist
// ==================================================================
function isAndroid() {
  return /Android/i.test(navigator.userAgent);
}


async function fetchWithRetry(url, options = {}) {
  let token = sessionStorage.getItem("access_token");
  if (!token) throw new Error("Î°úÍ∑∏Ïù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§.");

  options.headers = {
    ...(options.headers || {}),
    "Content-Type": "application/json",
    Authorization: `Bearer ${token}`,
  };

  let res = await fetch(url, options);

  // ÌÜ†ÌÅ∞ ÎßåÎ£åÏãú ÏûêÎèô Í∞±Ïã† ÌõÑ Ïû¨ÏãúÎèÑ
  if (res.status === 401) {
    const refreshRes = await fetch("/refresh-token");
    if (!refreshRes.ok) throw new Error("ÌÜ†ÌÅ∞ Í∞±Ïã† Ïã§Ìå®");

    const data = await refreshRes.json();
    sessionStorage.setItem("access_token", data.access_token);
    options.headers.Authorization = `Bearer ${data.access_token}`;

    res = await fetch(url, options); // Ïû¨ÏãúÎèÑ
  }

  return res;
}

async function searchTracks() {
  const query = document.getElementById("searchInput").value;
  try {
    const res = await fetchWithRetry("/search", {
      method: "POST",
      body: JSON.stringify({ query })
    });

    if (!res.ok) {
      const errorText = await res.text();
      throw new Error("Í≤ÄÏÉâ Ïã§Ìå®: " + errorText);
    }

    const tracks = await res.json();
    if (!Array.isArray(tracks)) throw new Error("ÏûòÎ™ªÎêú Îç∞Ïù¥ÌÑ∞ ÌòïÏãù");

    const resultDiv = document.getElementById("result");
    resultDiv.style.display = "block";
    resultDiv.innerHTML = ""; // Í∏∞Ï°¥ ÎÇ¥Ïö© Ï¥àÍ∏∞Ìôî

    // Î™®Îã¨ Î∞ïÏä§ ÏÉùÏÑ±
    const modal = document.createElement("div");
    modal.id = "result-modal";
    
    // Î™®Îã¨ Î∞∞Í≤Ω ÏÉùÏÑ±
    const modalBg = document.createElement("div");
    modalBg.id = "result-bg";
    modalBg.addEventListener("click", () => {
      resultDiv.style.display = "none";
    });

    // Îã´Í∏∞ Î≤ÑÌäº ÏÉùÏÑ±
    const closeBtn = document.createElement("button");
    closeBtn.id = "close";
    // closeBtn.classList.add("material-symbols-outlined");
    closeBtn.textContent = "close";
    closeBtn.addEventListener("click", () => {
      resultDiv.style.display = "none";
    });

    modal.appendChild(closeBtn); // Î™®Îã¨ ÏïàÏóê Î≤ÑÌäº ÎÑ£Í∏∞

    // Ìä∏Îûô Î¶¨Ïä§Ìä∏ Ï∂îÍ∞Ä
    tracks.forEach(track => {
      const div = document.createElement("div");
      div.innerHTML = `
        <div class="track-info">
          <p><strong>${track.name}</strong></p>
          <p>${track.artists.map(a => a.name).join(", ")}</p>
        </div>
        <button class="addBtn"><span class="material-symbols-outlined">add</span></button>
        <button class="playBtn" style="display: none;">Play</button>
      `;

      const addBtn = div.querySelector(".addBtn");
      const playBtn = div.querySelector(".playBtn");

      addBtn.addEventListener("click", async () => {
        try {
          const res = await fetchWithRetry("/add", {
            method: "POST",
            body: JSON.stringify({ uri: track.uri })
          });
          if (!res.ok) throw new Error("Ï∂îÍ∞Ä Ïã§Ìå®");
          loadPlaylistTracks();
          resultDiv.style.display = "none";
        } catch (e) {
          console.error("Ï∂îÍ∞Ä Ïò§Î•ò:", e.message);
        }
      });

      playBtn.addEventListener("click", () => {
        if (typeof playTrack === "function") {
          playTrack(track.uri);
        }
      });

      modal.appendChild(div); // Ìä∏ÎûôÏùÑ Î™®Îã¨Ïóê Ï∂îÍ∞Ä
    });

    resultDiv.appendChild(modal); // Î™®Îã¨ÏùÑ result ÏïàÏóê Ï∂îÍ∞Ä
    resultDiv.appendChild(modalBg);

    // Í≤ÄÏÉâÏ∞Ω Ï¥àÍ∏∞Ìôî
    document.getElementById("searchInput").value = "";

  } catch (e) {
    console.error("Í≤ÄÏÉâ Ï§ë Ïò§Î•ò:", e.message);
  }
}


async function loadPlaylistTracks() {
  try {
    const res = await fetchWithRetry("/playlist-tracks");

    if (!res.ok) throw new Error("Ïû¨ÏÉùÎ™©Î°ù Î∂àÎü¨Ïò§Í∏∞ Ïã§Ìå®");

    const items = await res.json();
    const container = document.getElementById("playlistContainer");
    container.innerHTML = "";

    items.forEach(({ track }, idx) => {
      const div = document.createElement("div");
      div.classList.add("track-item");
      div.setAttribute("data-uri", track.uri);
      div.innerHTML = `
        <!-- <img src="${track.album.images[2]?.url || ''}" alt="album cover" /> -->
        <div class="track-info">
          <p>${track.name} | ${track.artists.map(a => a.name).join(", ")}</p>
          <button class="deleteBtn"><span class="material-symbols-outlined"></span></button>
        </div>
        <audio controls src="${track.preview_url || ''}"></audio>
      `;

      const deleteBtn = div.querySelector(".deleteBtn");
      deleteBtn.addEventListener("click", async (e) => {
        e.stopPropagation();

        try {
          const res = await fetchWithRetry("/delete-track", {
            method: "POST",
            body: JSON.stringify({ uri: track.uri })
          });

          if (!res.ok) throw new Error("ÏÇ≠Ï†ú Ïã§Ìå®");
          loadPlaylistTracks(); // UI ÏÉàÎ°úÍ≥†Ïπ®
        } catch (err) {
          alert("ÏÇ≠Ï†ú Ï§ë Ïò§Î•ò Î∞úÏÉù: " + err.message);
        }
      });

      div.addEventListener("click", () => {
        window.playTrackAtIndex(idx);
      });
      container.appendChild(div);
    });

  } catch(e) {
    // alert("Ïû¨ÏÉùÎ™©Î°ù Î∂àÎü¨Ïò§Í∏∞ Ïã§Ìå®: " + e.message);
  }
}


document.getElementById("searchBtn").addEventListener("click", searchTracks);

document.getElementById("searchInput").addEventListener("keydown", (e) => {
  if (e.key === "Enter") {
    e.preventDefault();
    searchTracks();
  }
});

document.getElementById("close").addEventListener("click", () => {
  const resultDiv = document.getElementById("result");
  resultDiv.style.display = "none";
});

// window.onload = () => {
//   loadPlaylistTracks();           // Í∏∞Ï°¥ onload Ìï®Ïàò 1
//   fetchTotalPages(slug).then(() => {
//     goToPage(1); // Ï¥àÍ∏∞ Î°úÎî©
//   });
// };

// window.onload = () => {
//   loadPlaylistTracks();
//   fetchTotalPages(slug).then(() => {
//     console.log("üéØ Ï¥àÍ∏∞ totalPages:", totalPages);
//     goToPage(totalPages); // totalPages ÏÑ∏ÌåÖ ÌõÑ Ìò∏Ï∂ú
//   });
// };

window.onload = () => {
  loadPlaylistTracks(); // ÏûàÎã§Î©¥ Ïú†ÏßÄ
  fetchTotalPages(slug).then(() => {
    console.log("üéØ Ï¥àÍ∏∞ totalPages:", totalPages);
    goToPage(totalPages);  // ÏµúÏã† ÌéòÏù¥ÏßÄÎ°ú Ïù¥Îèô
  });
};

// Spotify SDK Ï¥àÍ∏∞Ìôî
window.onSpotifyWebPlaybackSDKReady = () => {
  const token = sessionStorage.getItem("access_token");
  if (!token) {
    // alert("Î°úÍ∑∏Ïù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§. Î®ºÏ†Ä /login ÏúºÎ°ú Î°úÍ∑∏Ïù∏ÌïòÏÑ∏Ïöî.");
    return;
  }

  const player = new Spotify.Player({
    name: "Shared Party Web Player",
    getOAuthToken: cb => { cb(token); },
    volume: 0.8,
  });

  let currentDeviceId = null;
  let playlistUris = [];
  let currentTrackIndex = 0;
  let isPaused = true;
  let pausedPositionMs = 0;
  let lastTrackUri = null;
  let isAdvancing = false;

  player.addListener('ready', ({ device_id }) => {
    console.log("‚úÖ Web Playback SDK Ïó∞Í≤∞Îê® (Device ID):", device_id);
    currentDeviceId = device_id;
  });

  if (!isAndroid()) {
    player.addListener('player_state_changed', (state) => {
      if (!state || !state.track_window?.current_track) return;

      const { paused, position, track_window } = state;
      const currentTrackUri = track_window.current_track.uri;

      console.log("üéß ÏÉÅÌÉú Î≥ÄÍ≤Ω Í∞êÏßÄ:", currentTrackUri, "position:", position, "paused:", paused);
      highlightPlayingTrack(currentTrackUri);

      if (isAdvancing) return;

      const songEnded = paused && position === 0;
      if (songEnded && playlistUris.length > 0) {
        isAdvancing = true;
        currentTrackIndex = (currentTrackIndex + 1) % playlistUris.length;
        const nextTrack = playlistUris[currentTrackIndex];
        lastTrackUri = nextTrack;

        console.log("‚è≠ Îã§Ïùå Í≥° Ïû¨ÏÉù:", nextTrack, "index:", currentTrackIndex);

        playTrack(nextTrack).then(() => {
          isAdvancing = false;
        }).catch(err => {
          console.error("Îã§Ïùå Í≥° Ïû¨ÏÉù Ïã§Ìå®:", err);
          isAdvancing = false;
        });
      } else {
        lastTrackUri = currentTrackUri;
      }
    });
  }

  player.connect();

  async function playTrack(trackUri, offsetMs = 0) {
    const android = isAndroid();
    const body = {
      uris: [trackUri],
      position_ms: offsetMs
    };
    const url = android
      ? `https://api.spotify.com/v1/me/player/play`
      : `https://api.spotify.com/v1/me/player/play?device_id=${currentDeviceId}`;
    try {
      const res = await fetch(url, {
        method: "PUT",
        body: JSON.stringify(body),
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${token}`,
        },
      });
      if (!res.ok) throw new Error("Ïû¨ÏÉù Ïã§Ìå®: " + await res.text());
      console.log(`üéµ Ïû¨ÏÉù ÏãúÏûë: ${trackUri} (position_ms: ${offsetMs})`);
      highlightPlayingTrack(trackUri);
      if (android) startPollingPlayerState();
    } catch (err) {
      // alert("Ïû¨ÏÉù Ï§ë Ïò§Î•ò: " + err.message);
    }
  }

  window.resumeTrack = async () => {
    const android = isAndroid();
    const body = {
      uris: playlistUris,
      offset: { position: currentTrackIndex },
      position_ms: pausedPositionMs,
    };
    const url = android
      ? "https://api.spotify.com/v1/me/player/play"
      : `https://api.spotify.com/v1/me/player/play?device_id=${currentDeviceId}`;
    try {
      const res = await fetch(url, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${token}`,
        },
        body: JSON.stringify(body),
      });
      if (!res.ok) throw new Error("Ïû¨ÏÉù Ïã§Ìå®: " + await res.text());
      console.log(`‚ñ∂ Ïù¥Ïñ¥ÏÑú Ï†ÑÏ≤¥ Ïû¨ÏÉù: index=${currentTrackIndex}, position=${pausedPositionMs}`);
      if (android) startPollingPlayerState();
    } catch (err) {
      // alert("Ïù¥Ïñ¥ Ïû¨ÏÉù Ïã§Ìå®: " + err.message);
    }
  };

  window.playAllTracks = (uris) => {
    playlistUris = uris;
    currentTrackIndex = 0;
    if (isAndroid()) {
      stopPollingPlayerState();
      playPlaylistOnAndroid(playlistUris, currentTrackIndex);
    } else {
      playTrack(playlistUris[currentTrackIndex]);
    }
  };

  async function playPlaylistOnAndroid(uris, index = 0) {
    try {
      const res = await fetch("https://api.spotify.com/v1/me/player/play", {
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${token}`,
        },
        body: JSON.stringify({
          uris: uris,
          offset: { position: index },
          position_ms: 0,
        }),
      });
      if (!res.ok) throw new Error("Ïû¨ÏÉù Ïã§Ìå®: " + await res.text());
      console.log("‚ñ∂Ô∏è AndroidÏö© Ï†ÑÏ≤¥ Ïû¨ÏÉù ÏãúÏûëÎê®");
      startPollingPlayerState();
    } catch (err) {
      // alert("Android Ïû¨ÏÉù Ï§ë Ïò§Î•ò: " + err.message);
    }
  }

  window.pauseTrack = async () => {
    const android = isAndroid();
    const url = android
      ? "https://api.spotify.com/v1/me/player/pause"
      : `https://api.spotify.com/v1/me/player/pause?device_id=${currentDeviceId}`;
    try {
      const res = await fetch("https://api.spotify.com/v1/me/player", {
        headers: { "Authorization": `Bearer ${token}` },
      });
      const data = await res.json();
      pausedPositionMs = data.progress_ms || 0;
      await fetch(url, {
        method: "PUT",
        headers: { "Authorization": `Bearer ${token}` },
      });
      console.log("‚è∏ ÏùºÏãú Ï§ëÏßÄ @", pausedPositionMs);
    } catch (err) {
      // alert("ÏùºÏãú Ï§ëÏßÄ Ïã§Ìå®: " + err.message);
    }
  };

  window.stopTrack = async () => {
    await window.pauseTrack();
    stopPollingPlayerState();
    playlistUris = [];
    currentTrackIndex = 0;
    console.log("‚èπ Ïû¨ÏÉù Ï§ëÏßÄ");
  };

  window.playTrackAtIndex = (index) => {
    if (index < 0 || index >= playlistUris.length) {
      // alert("ÏûòÎ™ªÎêú Í≥° Ïù∏Îç±Ïä§ÏûÖÎãàÎã§.");
      return;
    }
    currentTrackIndex = index;
    if (isAndroid()) {
      playPlaylistOnAndroid(playlistUris, currentTrackIndex);
    } else {
      playTrack(playlistUris[currentTrackIndex]);
    }
  };
};


// ==========================================================================================
let pollIntervalId = null;

function startPollingPlayerState() {
  stopPollingPlayerState(); // Ï§ëÎ≥µ Î∞©ÏßÄ

  pollIntervalId = setInterval(async () => {
    try {
      const res = await fetch("https://api.spotify.com/v1/me/player", {
        headers: {
          "Authorization": `Bearer ${sessionStorage.getItem("access_token")}`,
        },
      });

      if (!res.ok) throw new Error(await res.text());
      const data = await res.json();

      const currentTrackUri = data.item?.uri;
      const position = data.progress_ms;
      const duration = data.item?.duration_ms;
      const paused = data.is_playing === false;
      
      if (currentTrackUri && playlistUris.includes(currentTrackUri)) {
        const index = playlistUris.indexOf(currentTrackUri);
        if (index !== -1) {
          currentTrackIndex = index;
          highlightPlayingTrack(currentTrackUri); // ‚úÖ Ïù¥ ÏãúÏ†êÏóê ÌïòÏù¥ÎùºÏù¥Ìä∏
        }
      } else {
        console.warn("üîé ÌòÑÏû¨ Ìä∏ÎûôÏù¥ ÌîåÎ†àÏù¥Î¶¨Ïä§Ìä∏Ïóê ÏóÜÏäµÎãàÎã§:", currentTrackUri);
      }

      // ‚úÖ ÌòÑÏû¨ Ïû¨ÏÉù Ï§ëÏù∏ Í≥°Ïùò Ïù∏Îç±Ïä§ Ï∂îÏ†Å
      const newIndex = playlistUris.indexOf(currentTrackUri);
      if (newIndex >= 0) {
        currentTrackIndex = newIndex;
      }

      // ‚úÖ Îã§Ïùå Í≥°ÏúºÎ°ú ÏûêÎèô Ï†ÑÌôò
      const songEnded = paused && position < 1000;
      if (songEnded && playlistUris.length > 0) {
        const nextIndex = (currentTrackIndex + 1) % playlistUris.length;
        console.log("‚è≠ Android Îã§Ïùå Í≥°ÏúºÎ°ú:", playlistUris[nextIndex]);
        currentTrackIndex = nextIndex;
        await playPlaylistOnAndroid(playlistUris, nextIndex);
      }

    } catch (err) {
      console.warn("üéß Android ÏÉÅÌÉú ÌôïÏù∏ Ïã§Ìå®:", err.message);
    }
  }, 2000);
}

function stopPollingPlayerState() {
  if (pollIntervalId) {
    clearInterval(pollIntervalId);
    pollIntervalId = null;
  }
}


// ==========================================================================================

let isPlaying = false;
let playlistLoaded = false;

document.getElementById("playAllBtn").addEventListener("click", async () => {
  try {
    if (!playlistLoaded) {
      const res = await fetchWithRetry("/playlist-tracks");
      if (!res.ok) throw new Error("Ïû¨ÏÉùÎ™©Î°ù Î∂àÎü¨Ïò§Í∏∞ Ïã§Ìå®");

      const items = await res.json();
      const uris = items.map(item => item.track?.uri).filter(Boolean);
      if (!uris.length) {
        // alert("Ïû¨ÏÉù Í∞ÄÎä•Ìïú Í≥°Ïù¥ ÏóÜÏäµÎãàÎã§.");
        return;
      }

      window.playAllTracks(uris); // üîÅ Ï†ÑÏ≤¥ Ïû¨ÏÉù ÏãúÏûë
      isPlaying = true;
      playlistLoaded = true;
      updatePlayAllButtonText();
      return;
    }

    if (isPlaying) {
      await window.pauseTrack();     // üîÅ ÏùºÏãúÏ†ïÏßÄ
      isPlaying = false;
    } else {
      window.resumeTrack();          // üîÅ Ïù¥Ïñ¥ÏÑú Ïû¨ÏÉù
      isPlaying = true;
    }

    updatePlayAllButtonText();

  } catch (e) {
    // alert("Ïû¨ÏÉù Ïã§Ìå®: " + e.message);
  }
});

function updatePlayAllButtonText() {
  const icon = document.querySelector("#playAllBtn .material-symbols-outlined");
  if (icon) {
    icon.textContent = isPlaying ? "pause" : "play_arrow";
  }
}


// Ïû¨ÏÉùÎ™©Î°ùÏóêÏÑú ÌäπÏ†ï Í≥° ÌÅ¥Î¶≠ Ïãú
function loadPlaylistTracks() {
  fetch("/playlist-tracks")
    .then(res => res.json())
    .then(items => {
      const container = document.getElementById("playlistContainer");
      container.innerHTML = "";
      items.forEach(({ track }, idx) => {
        const div = document.createElement("div");
        div.classList.add("track-item");
        div.setAttribute("data-uri", track.uri); 

        div.innerHTML = `
          <!-- <img src="${track.album.images[2]?.url || ''}" alt="album cover" /> -->
          <div class="track-info">
            <p>${track.name} | ${track.artists.map(a => a.name).join(", ")}</p>
            <button class="deleteBtn"><span class="material-symbols-outlined"></span></button>
          </div>
        `;

        const deleteBtn = div.querySelector(".deleteBtn");
        deleteBtn.addEventListener("click", async (e) => {
          e.stopPropagation();

          try {
            const res = await fetchWithRetry("/delete-track", {
              method: "POST",
              body: JSON.stringify({ uri: track.uri })
            });

            if (!res.ok) throw new Error("ÏÇ≠Ï†ú Ïã§Ìå®");
            loadPlaylistTracks(); // UI ÏÉàÎ°úÍ≥†Ïπ®
          } catch (err) {
            alert("ÏÇ≠Ï†ú Ï§ë Ïò§Î•ò Î∞úÏÉù: " + err.message);
          }
        });

        div.addEventListener("click", () => {
          window.playTrackAtIndex(idx);
        });
        container.appendChild(div);
      });
    });
}

// ÌòÑÏû¨ Í≥° Í∞ïÏ°∞ÌïòÎäî Ìï®Ïàò
// function highlightPlayingTrack(trackUri) {
//   const currentlyPlayingEl = document.querySelector(".playing");
//   const currentHighlightedUri = currentlyPlayingEl?.getAttribute("data-uri");

//   if (currentHighlightedUri === trackUri) return; // üõë Ïù¥ÎØ∏ Í∞ïÏ°∞Îêú Í≥°Ïù¥Î©¥ Î¨¥Ïãú

//   document.querySelectorAll("[data-uri]").forEach(el => {
//     el.classList.remove("playing");
//   });

//   const current = document.querySelector(`[data-uri="${trackUri}"]`);
//   if (current) current.classList.add("playing");
// }


function highlightPlayingTrack(trackUri) {
  // Í∏∞Ï°¥ Í∞ïÏ°∞ Ï†úÍ±∞
  document.querySelectorAll("[data-uri]").forEach(el => {
    el.classList.remove("playing");

    // Ïù¥Ï†Ñ #playing span Ï†úÍ±∞ (Ï§ëÎ≥µ Î∞©ÏßÄ)
    const existingIndicator = el.querySelector("#playing");
    if (existingIndicator) existingIndicator.remove();
  });

  // ÌòÑÏû¨ Ïû¨ÏÉù Ï§ëÏù∏ Ìï≠Î™© Í∞ïÏ°∞
  const current = document.querySelector(`[data-uri="${trackUri}"]`);
  if (current) {
    current.classList.add("playing");

    //#playing ÌëúÏãú Ï∂îÍ∞Ä
    // const playingSpan = document.createElement("span");
    // playingSpan.id = "playing";
    // playingSpan.classList.add("material-symbols-outlined");
    // playingSpan.textContent = "‚Ä¢";
    // current.querySelector(".track-info")?.appendChild(playingSpan);
  }
}

// =============================‚óè=============================================================
// TV
// ==========================================================================================
// let slug = 'sol-ra-dio';
let slug = 'twa-memories';
let page = 1; // Ïã§Ï†ú Î≥¥Ïó¨Ï£ºÎäî ÏΩòÌÖêÏ∏† Ïù∏Îç±Ïä§ (1Î∂ÄÌÑ∞ ÏãúÏûë)
let totalPages = 1; // Ï†ÑÏ≤¥ ÏΩòÌÖêÏ∏† Ïàò = ÌéòÏù¥ÏßÄ Ïàò (ÏΩòÌÖêÏ∏† 1Í∞úÎãπ 1ÌéòÏù¥ÏßÄ)
let buttonsPerPage = 14;

let arenaPage = 1; // Are.na APIÏùò page=1, 2, 3...
let cachedContents = []; // ÌòÑÏû¨ arenaPageÏóêÏÑú Î∞õÏïÑÏò® 100Í∞ú ÏΩòÌÖêÏ∏† Ï∫êÏãú

// Ïã§ÏãúÍ∞Ñ ÎèôÍ∏∞ÌôîÎ•º ÏúÑÌïú Ï†ÑÏó≠ ÏÉÅÌÉú
// let currentSlug = slug;
// let currentPage = page;



// =============================================================
// TV: btns
// =============================================================




function goToPage(newPage) {
  console.log('‚ñ∂ goToPage Ìò∏Ï∂ú:', newPage);
  page = newPage;
  arenaPage = Math.floor((page - 1) / 100) + 1;
  playNoiseAudio();
  loadArenaPage(slug, arenaPage);
}

document.getElementById('btn-N').addEventListener('click', () => goToPage(page - 1));
document.getElementById('btn-P').addEventListener('click', () => goToPage(page + 1));

  
// =============================================================
// ÌéòÏù¥ÏßÄ Î≤ÑÌäº Î∞è ÏÉÅÌÉú
// =============================================================

function btnPageCounter() {
  document.getElementById('btn-P').disabled = (page === totalPages);
  document.getElementById('btn-N').disabled = (page === 1);
}


function btnPages() {
  const paginationContainer = document.querySelector('.btn-pages');
  if (!paginationContainer) {
    console.warn('‚ùå paginationContainerÍ∞Ä ÏóÜÏäµÎãàÎã§.');
    return;
  }

  console.log("üéØ totalPages in btnPages:", totalPages);
  console.log("üéØ current page:", page);

  // Í∏∞Ï°¥ Ïà´Ïûê Î≤ÑÌäº Ï†úÍ±∞ (Ïù¥Ï†Ñ/Îã§Ïùå Î≤ÑÌäº Ï†úÏô∏)
  const oldButtons = Array.from(paginationContainer.querySelectorAll('button'));
  oldButtons.forEach(btn => {
    if (!['btn-P', 'btn-N'].includes(btn.id)) {
      btn.remove();
    }
  });

  const nextBtn = document.getElementById('btn-N');

  // ÌòÑÏû¨ ÌéòÏù¥ÏßÄÍ∞Ä ÏÜçÌïú Î∏îÎ°ù Îã®ÏúÑÎ°ú Î≤ÑÌäº Î≤îÏúÑ Í≥ÑÏÇ∞
  // (Ïòà: page=103Ïù¥Î©¥ [103~89], page=88Ïù¥Î©¥ [88~74])
  const blockIndex = Math.floor((totalPages - page) / buttonsPerPage);
  const endPage = totalPages - blockIndex * buttonsPerPage;
  const startPage = Math.max(1, endPage - buttonsPerPage + 1);

  // Ïó≠ÏàúÏúºÎ°ú Î≤ÑÌäº ÏÉùÏÑ±
  for (let i = endPage; i >= startPage; i--) {
    const button = document.createElement('button');
    button.textContent = i;
    button.disabled = (i === page);
    button.addEventListener('click', () => goToPage(i));
    paginationContainer.insertBefore(button, nextBtn);
  }
}



// =============================================================
// ÏΩòÌÖêÏ∏† Î∂àÎü¨Ïò§Í∏∞
// =============================================================

function loadArenaPage(slug, arenaPage) {
  const url = `https://api.are.na/v2/channels/${slug}/contents?page=${arenaPage}&per=100`;
  return fetch(url)
    .then(res => res.json())
    .then(data => {
      cachedContents = data.contents;

      // ÎßàÏßÄÎßâ ÌéòÏù¥ÏßÄ Í∞êÏßÄ: 100Í∞ú ÎØ∏ÎßåÏù¥Î©¥ Í∑∏Í≤å ÎßàÏßÄÎßâ ÌéòÏù¥ÏßÄ
      if (data.contents.length < 100) {
        const accurateTotalPages = (arenaPage - 1) * 100 + data.contents.length;
        if (accurateTotalPages !== totalPages) {
          totalPages = accurateTotalPages;
          console.log("üéØ Ï†ïÌôïÌïú totalPages Í∞±Ïã†Îê®:", totalPages);

          // ÌòÑÏû¨ totalPagesÏóê ÎßûÏ∂∞ Îã§Ïãú Ïù¥Îèô
          goToPage(totalPages);
          return; // Ï§ëÎ≥µ Ï≤òÎ¶¨ Î∞©ÏßÄ
        }
      }

      renderChannel(slug, page);
      btnPages();
      btnPageCounter();
    });
}



// function fetchTotalPages(slug) {
//   const url = `https://api.are.na/v2/channels/${slug}`;
//   return fetch(url)
//     .then(res => res.json())
//     .then(data => {
//       // ‚úÖ Í∞ÄÎä•Ìïú ÌïÑÎìú Î™®Îëê Ï≤¥ÌÅ¨
//       totalPages = data.length || data.contents_count;

//       if (!totalPages) {
//         console.warn("‚ùå totalPagesÎ•º Í≥ÑÏÇ∞Ìï† Ïàò ÏóÜÏäµÎãàÎã§. ÏùëÎãµ Íµ¨Ï°∞Î•º ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.", data);
//       } else {
//         console.log("‚úÖ totalPages Í≥ÑÏÇ∞Îê®:", totalPages);
//       }
//     })
//     .catch(err => {
//       console.error("‚ùå totalPages Í≥ÑÏÇ∞ Ïã§Ìå®:", err);
//     });
// }

function fetchTotalPages(slug) {
  const url = `https://api.are.na/v2/channels/${slug}`;
  return fetch(url)
    .then(res => res.json())
    .then(data => {
      totalPages = data.length || data.contents_count;
      console.log("‚úÖ totalPages Í≥ÑÏÇ∞Îê®:", totalPages);
    })
    .catch(err => {
      console.error("‚ùå totalPages Í≥ÑÏÇ∞ Ïã§Ìå®:", err);
    });
}



// =============================================================
// API: Content
// =============================================================

function renderChannel(slug, page) {
  const localIndex = (page - 1) % 100;
  const block = cachedContents[localIndex];
  if (!block) return;

  const picNumber = String(page).padStart(3, "0");
  const asciiArtList = [
`=============================

,_('--,       
   (.--; ,--')_,
     | ;--.)
 .-. |.| .-.
  |/|/
=============================`,
`wwwwwwwwwwwwwwwwwwwwwwwwwwwww
       ____
___    {__)_)
{_)_}   {__>__}
{__<__}.  (_(_}.  
(_)_)   |\|    
  |\|/|    \| /|.  
 ,.\|/.,,   |//..  
wwwwwwwwwwwwwwwwwwwwwwwwwwwww`,
`=============================
 __   _
 _(  )_( )_
(_   __    _)
(_) (__)
=============================`,
  ];

  let html = '';

  switch (block.class) {
    case "Image":
    case "Attachment":
      html = `
        <div class="img_screen">
          <div class="img_print">
            <img class="Block_img noise" src="img_tv/noise_4.gif">
            <img class="Block_img dithered" src="${block.image.large.url}"/>
          </div>
        </div>
        <textarea id="note" rows="3">
${block.title || ""}

${block.description || ""}
${asciiArtList[Math.floor(Math.random() * asciiArtList.length)]}
Sol-Ra.dio            Pic.${picNumber}</textarea>
      `;
      break;

    case "Text":
      html = `<p class="Block_text">${block.content}</p>`;
      break;

    case "Media":
    case "Link":
      html = `
        <div class="Block_loop">
          <img class="Block_loop_img_cover" src="img/noise.gif">
          <img class="Block_loop_img" style="transform: translate(0, -100%);" src="${block.image.large.url}">
          <img class="Block_loop_img" src="${block.image.large.url}">
          <img class="Block_loop_img" style="transform: translate(0, 100%);" src="${block.image.large.url}">
        </div>
      `;
      break;
  }

  const contents = document.getElementsByClassName("ARENA-container")[0];
  contents.innerHTML = `<div class="Block ${block.class}">${html}</div>`;
  applyDithering();
}


// ================================================
// Ïã§ÏãúÍ∞Ñ ÏûêÎèô ÏóÖÎç∞Ïù¥Ìä∏ Ï∂îÍ∞Ä (30Ï¥àÎßàÎã§)
// ================================================

// setInterval(() => {
//   fetchTotalPages(currentSlug).then(() => {
//     renderChannel(currentSlug, currentPage);
//     btnPages();
//     btnPageCounter();
//   });
// }, 5000); // 30,000ms = 30Ï¥à

// document.getElementById('refresh').addEventListener('click', function() {
//   playNoiseAudio();
//   fetchTotalPages(slug).then(() => {
//     renderChannel(slug, page);
//     btnPages();
//     btnPageCounter();
//   });
// });

document.getElementById('refresh').addEventListener('click', function () {
  playNoiseAudio();

  // ÏµúÏã† ÌéòÏù¥ÏßÄ Î≤àÌò∏ Í≥ÑÏÇ∞ ÌõÑ Ïù¥Îèô
  fetchTotalPages(slug).then(() => {
    goToPage(totalPages);
  });
});


// ================================================
// Noise Ïû¨ÏÉù
// ================================================
function playNoiseAudio() {
  const audio = document.getElementById('noise-audio');
  if (audio) {
    audio.currentTime = 0; // Ìï≠ÏÉÅ Ï≤òÏùåÎ∂ÄÌÑ∞ Ïû¨ÏÉù
    audio.play().catch(e => {
      // ÏÇ¨Ïö©Ïûê ÏÉÅÌò∏ÏûëÏö© ÏóÜÏùÑ ÎïåÎäî play()Í∞Ä Ïã§Ìå®Ìï† Ïàò ÏûàÏùå ‚Üí Î¨¥ÏãúÌï¥ÎèÑ Îê®
      console.warn("Audio play failed:", e);
    });
  }
}

//   "id": 76969,
//   "title": "The Working Sheepdog ( Border Collies ) in training",
//   "updated_at": "2020-04-07T21:59:29.806Z",
//   "created_at": "2013-02-12T22:40:15.696Z",
//   "state": "available",
//   "comment_count": 0,
//   "generated_title": "The Working Sheepdog ( Border Collies ) in training",
//   "content_html": "",
//   "description_html": "<p>Border Collie Collies working sheepdog Sheep dogs in training Scotland</p>",
//   "visibility": "public",
//   "content": "",
//   "description": "Border Collie Collies working sheepdog Sheep dogs in training Scotland",
//   "source": {},
//   "image": {},
//   "embed": {},
//   "attachment": null,
//   "metadata": null,
//   "base_class": "Block",
//   "class": "Media",
//   "user": {},
//   "position": 1,
//   "selected": false,
//   "connection_id": 716562,
//   "connected_at": "2016-05-16T00:59:42.901Z",
//   "connected_by_user_id": 128,
//   "connected_by_username": "Chris Sherr√≥n", // ${block.connected_by_username}
//   "connected_by_user_slug": "chris-sherron"



// =============================================================
// Dithering
// =============================================================
function floydSteinbergDither(image, callback) {
  const targetWidth = 450;
  const scale = targetWidth / image.width;
  const targetHeight = Math.floor(image.height * scale);

  const canvas = document.createElement('canvas');
  canvas.width = targetWidth;
  canvas.height = targetHeight;
  const ctx = canvas.getContext('2d');

  ctx.drawImage(image, 0, 0, targetWidth, targetHeight);

  const imageData = ctx.getImageData(0, 0, targetWidth, targetHeight);
  const data = imageData.data;
  const gray = new Array(targetWidth * targetHeight);

  for (let i = 0; i < data.length; i += 4) {
    const r = data[i], g = data[i + 1], b = data[i + 2];
    gray[i / 4] = 0.299 * r + 0.587 * g + 0.114 * b;
  }

  for (let y = 0; y < targetHeight; y++) {
    for (let x = 0; x < targetWidth; x++) {
      const i = y * targetWidth + x;
      const old = gray[i];
      const newPixel = old < 128 ? 0 : 255;
      const error = old - newPixel;
      gray[i] = newPixel;

      if (x + 1 < targetWidth) gray[i + 1] += error * 7 / 16;
      if (x > 0 && y + 1 < targetHeight) gray[i + targetWidth - 1] += error * 3 / 16;
      if (y + 1 < targetHeight) gray[i + targetWidth] += error * 5 / 16;
      if (x + 1 < targetWidth && y + 1 < targetHeight) gray[i + targetWidth + 1] += error * 1 / 16;
    }
  }

  for (let i = 0; i < data.length; i += 4) {
    const v = gray[i / 4] < 128 ? 0 : 255;
    data[i] = data[i + 1] = data[i + 2] = v;
    data[i + 3] = 255;
  }

  ctx.putImageData(imageData, 0, 0);
  callback(canvas.toDataURL());
}

// Î†åÎçîÎßÅ Ïù¥ÌõÑ ÎîîÎçîÎßÅ Ï†ÅÏö©
function applyDithering() {
  const images = document.querySelectorAll('img.dithered');
  images.forEach(img => {
    const image = new Image();
    image.crossOrigin = 'anonymous';
    image.src = img.src;
    image.onload = () => {
      floydSteinbergDither(image, dataURL => {
        img.src = dataURL;
      });
    };
  });
}

